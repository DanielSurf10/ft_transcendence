<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong Game - ft_transcendence</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        #gameHeader {
            margin-bottom: 20px;
        }

        #gameHeader h1 {
            font-size: 3em;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 10px;
        }

        #score {
            font-size: 2em;
            font-weight: bold;
            color: #00ff88;
        }

        #gameArea {
            margin: 20px 0;
        }

        #pongCanvas {
            border: 3px solid #00ffff;
            border-radius: 10px;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        #gameControls {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 10px;
        }

        .control-group h3 {
            color: #00ff88;
            margin-bottom: 8px;
        }

        .control-group p {
            font-size: 1.2em;
        }

        #gameMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .menu-content {
            background: #1a1a2e;
            padding: 40px;
            border-radius: 15px;
            border: 2px solid #00ffff;
            text-align: center;
        }

        .menu-content h2 {
            color: #00ffff;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .player-inputs {
            margin: 20px 0;
        }

        .player-inputs input {
            display: block;
            width: 200px;
            padding: 10px;
            margin: 10px auto;
            background: #000;
            border: 2px solid #00ffff;
            border-radius: 5px;
            color: white;
            font-size: 1.1em;
            text-align: center;
        }

        .player-inputs input::placeholder {
            color: #666;
        }

        #startGame {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 12px 30px;
            font-size: 1.2em;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        #startGame:hover {
            background: #00ffff;
            transform: scale(1.05);
            box-shadow: 0 0 15px #00ffff;
        }

        .hidden {
            display: none !important;
        }

        /* Responsive */
        @media (max-width: 850px) {
            #pongCanvas {
                width: 95vw;
                height: auto;
            }

            #gameControls {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameHeader">
            <h1>PONG</h1>
            <div id="score">
                <span id="player1Score">0</span> - <span id="player2Score">0</span>
            </div>
        </div>

        <div id="gameArea">
            <canvas id="pongCanvas" width="800" height="400"></canvas>
        </div>

        <div id="gameControls">
            <div class="control-group">
                <h3>Player 1</h3>
                <p>W ⬆️ | S ⬇️</p>
            </div>
            <div class="control-group">
                <h3>Player 2</h3>
                <p>↑ ⬆️ | ↓ ⬇️</p>
            </div>
        </div>

        <div id="gameMenu">
            <div class="menu-content">
                <h2>Pong Tournament</h2>
                <div class="player-inputs">
                    <input type="text" id="player1Name" placeholder="Player 1 Name" maxlength="10" value="Player 1">
                    <input type="text" id="player2Name" placeholder="Player 2 Name" maxlength="10" value="Player 2">
                </div>
                <button id="startGame">Start Game</button>
            </div>
        </div>
    </div>

    <script>
        class Ball {
            constructor(canvasWidth, canvasHeight) {
                this.radius = 8;
                this.baseSpeed = 5;
                this.reset(canvasWidth, canvasHeight);
            }

            reset(canvasWidth, canvasHeight) {
                this.x = canvasWidth / 2;
                this.y = canvasHeight / 2;
                this.speedX = (Math.random() > 0.5 ? 1 : -1) * this.baseSpeed;
                this.speedY = (Math.random() - 0.5) * this.baseSpeed;

                // Garante uma velocidade mínima no eixo Y
                if (Math.abs(this.speedY) < 1) {
                    this.speedY = this.speedY > 0 ? 1 : -1;
                }
            }

            update(canvasWidth, canvasHeight) {
                this.x += this.speedX;
                this.y += this.speedY;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.closePath();
            }

            // Aumenta gradualmente a velocidade para manter o jogo emocionante
            increaseSpeed() {
                this.speedX *= 1.02;
                this.speedY *= 1.02;
            }
        }

        class Paddle {
            constructor(x, canvasHeight, isAI = false) {
                this.width = 10;
                this.height = 80;
                this.x = x;
                this.y = canvasHeight / 2 - this.height / 2;
                this.speed = 8;
                this.score = 0;
                this.isAI = isAI;
            }

            update(canvasHeight, ball) {
                if (this.isAI && ball) {
                    this.aiMove(canvasHeight, ball);
                }

                // Mantém a raquete dentro dos limites
                if (this.y < 0) this.y = 0;
                if (this.y + this.height > canvasHeight) this.y = canvasHeight - this.height;
            }

            // Movimento simples da IA
            aiMove(canvasHeight, ball) {
                const paddleCenter = this.y + this.height / 2;
                const ballCenter = ball.y;

                // A IA tem um tempo de reação e ocasionalmente erra
                if (Math.random() < 0.02) return; // Às vezes não reage

                // Move em direção à bola com pequeno erro
                const error = (Math.random() - 0.5) * 20;
                const targetY = ballCenter + error - this.height / 2;

                // Move gradualmente
                if (targetY > this.y) {
                    this.y += Math.min(this.speed * 0.7, targetY - this.y);
                } else if (targetY < this.y) {
                    this.y -= Math.min(this.speed * 0.7, this.y - targetY);
                }
            }

            moveUp() {
                this.y -= this.speed;
            }

            moveDown() {
                this.y += this.speed;
            }

            draw(ctx) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Adiciona um efeito visual nas raquetes
                ctx.fillStyle = this.isAI ? '#ff4444' : '#4444ff';
                ctx.fillRect(this.x, this.y + this.height / 2 - 10, this.width, 20);
            }

            reset(canvasHeight) {
                this.y = canvasHeight / 2 - this.height / 2;
            }
        }

        class CollisionSystem {
            static checkWallCollision(ball, canvasHeight) {
                // Colisão com topo e base
                if (ball.y - ball.radius <= 0) {
                    ball.y = ball.radius;
                    ball.speedY = Math.abs(ball.speedY);
                } else if (ball.y + ball.radius >= canvasHeight) {
                    ball.y = canvasHeight - ball.radius;
                    ball.speedY = -Math.abs(ball.speedY);
                }
            }

            static checkPaddleCollision(ball, paddle) {
                const ballLeft = ball.x - ball.radius;
                const ballRight = ball.x + ball.radius;
                const ballTop = ball.y - ball.radius;
                const ballBottom = ball.y + ball.radius;

                const paddleLeft = paddle.x;
                const paddleRight = paddle.x + paddle.width;
                const paddleTop = paddle.y;
                const paddleBottom = paddle.y + paddle.height;

                // Verifica se há colisão
                if (ballRight >= paddleLeft &&
                    ballLeft <= paddleRight &&
                    ballBottom >= paddleTop &&
                    ballTop <= paddleBottom) {

                    this.handlePaddleBounce(ball, paddle);
                    return true;
                }

                return false;
            }

            static handlePaddleBounce(ball, paddle) {
                // Inverte a direção X
                ball.speedX = -ball.speedX;

                // Ajusta o ângulo baseado em onde a bola acertou a raquete
                const hitPosition = (ball.y - paddle.y) / paddle.height; // 0 a 1
                const angle = (hitPosition - 0.5) * Math.PI / 3; // ±60 graus máximo

                // Calcula as novas velocidades
                const speed = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);
                ball.speedX = Math.cos(angle) * speed * Math.sign(ball.speedX);
                ball.speedY = Math.sin(angle) * speed;

                // Ajusta a posição para evitar colisões múltiplas
                if (ball.speedX > 0) {
                    ball.x = paddle.x + paddle.width + ball.radius;
                } else {
                    ball.x = paddle.x - ball.radius;
                }

                // Aumenta ligeiramente a velocidade
                ball.increaseSpeed();
            }

            static checkScore(ball, canvasWidth) {
                // Retorna 1 se player 1 marcou, 2 se player 2 marcou, 0 se não marcou
                if (ball.x - ball.radius <= 0) {
                    return 2; // Player 2 pontua
                } else if (ball.x + ball.radius >= canvasWidth) {
                    return 1; // Player 1 pontua
                }
                return 0;
            }
        }

        class PongGame {
            constructor() {
                this.canvas = document.getElementById('pongCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.keys = {};
                this.isRunning = false;

                // Inicializa elementos da UI
                this.player1ScoreElement = document.getElementById('player1Score');
                this.player2ScoreElement = document.getElementById('player2Score');
                this.gameMenu = document.getElementById('gameMenu');
                this.startButton = document.getElementById('startGame');
                this.player1Input = document.getElementById('player1Name');
                this.player2Input = document.getElementById('player2Name');

                // Inicializa objetos do jogo
                this.ball = new Ball(this.canvas.width, this.canvas.height);
                this.paddle1 = new Paddle(20, this.canvas.height, false);
                this.paddle2 = new Paddle(this.canvas.width - 30, this.canvas.height, false); // Dois jogadores humanos

                this.setupEventListeners();
            }

            setupEventListeners() {
                // Controles de teclado
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });

                // Botão de iniciar jogo
                this.startButton.addEventListener('click', () => {
                    this.startGame();
                });

                // Enter também inicia o jogo
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !this.isRunning) {
                        this.startGame();
                    }
                });
            }

            startGame() {
                // Configura nomes dos jogadores
                const player1Name = this.player1Input.value || 'Player 1';
                const player2Name = this.player2Input.value || 'Player 2';

                this.gameMenu.classList.add('hidden');
                this.resetGame();
                this.isRunning = true;
                this.gameLoop();
            }

            resetGame() {
                this.paddle1.score = 0;
                this.paddle2.score = 0;
                this.updateScore();
                this.ball.reset(this.canvas.width, this.canvas.height);
                this.paddle1.reset(this.canvas.height);
                this.paddle2.reset(this.canvas.height);
            }

            update() {
                // Movimenta as raquetes baseado nas teclas pressionadas
                if (this.keys['w'] || this.keys['W']) {
                    this.paddle1.moveUp();
                }
                if (this.keys['s'] || this.keys['S']) {
                    this.paddle1.moveDown();
                }
                if (this.keys['ArrowUp']) {
                    this.paddle2.moveUp();
                }
                if (this.keys['ArrowDown']) {
                    this.paddle2.moveDown();
                }

                // Atualiza posições
                this.paddle1.update(this.canvas.height);
                this.paddle2.update(this.canvas.height);
                this.ball.update(this.canvas.width, this.canvas.height);

                // Verifica colisões
                CollisionSystem.checkWallCollision(this.ball, this.canvas.height);

                // Colisão com raquetes
                if (CollisionSystem.checkPaddleCollision(this.ball, this.paddle1) ||
                    CollisionSystem.checkPaddleCollision(this.ball, this.paddle2)) {
                    // Som de colisão (pode adicionar depois)
                }

                // Verifica pontuação
                const score = CollisionSystem.checkScore(this.ball, this.canvas.width);
                if (score === 1) {
                    this.paddle1.score++;
                    this.updateScore();
                    this.ball.reset(this.canvas.width, this.canvas.height);
                } else if (score === 2) {
                    this.paddle2.score++;
                    this.updateScore();
                    this.ball.reset(this.canvas.width, this.canvas.height);
                }

                // Verifica se alguém ganhou
                if (this.paddle1.score >= 5 || this.paddle2.score >= 5) {
                    this.gameOver();
                }
            }

            updateScore() {
                this.player1ScoreElement.textContent = this.paddle1.score.toString();
                this.player2ScoreElement.textContent = this.paddle2.score.toString();
            }

            draw() {
                // Limpa o canvas
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Desenha a linha central pontilhada
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.setLineDash([5, 15]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.canvas.width / 2, 0);
                this.ctx.lineTo(this.canvas.width / 2, this.canvas.height);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // Desenha os objetos do jogo
                this.ball.draw(this.ctx);
                this.paddle1.draw(this.ctx);
                this.paddle2.draw(this.ctx);

                // Desenha o círculo central
                this.ctx.beginPath();
                this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, 50, 0, Math.PI * 2);
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.stroke();
            }

            gameOver() {
                this.isRunning = false;
                cancelAnimationFrame(this.animationId);

                const winner = this.paddle1.score >= 5 ? this.player1Input.value || 'Player 1' : this.player2Input.value || 'Player 2';
                setTimeout(() => {
                    alert(`Game Over! ${winner} wins!`);
                    this.gameMenu.classList.remove('hidden');
                }, 500);
            }

            gameLoop = () => {
                this.update();
                this.draw();

                if (this.isRunning) {
                    this.animationId = requestAnimationFrame(this.gameLoop);
                }
            }
        }

        // Inicializa o jogo quando a página carregar
        window.addEventListener('load', () => {
            new PongGame();
        });
    </script>
</body>
</html>
